---
종류: 문헌
날짜: 2023-09-07
인물_저자: 윤성우
태그: 프로그래밍,네트워크
출처: 윤성우의 열혈 TCP IP 소켓 프로그래밍
구분_장소_분류: ""
aliases: []
---

### 날짜: 2023-09-07 18:45
### 태그: #프로그래밍/네트워크

>[!메모]
> 

### 학습 내용
---
## epoll의 이해와 활용
- select는 동시접속자의 수가 100을 넘기 힘들다.
### select 기반의 IO 멀티플렉싱이 느린 이유
- 모든 파일 디스크립터를 검사하는 반복문
- select를 호출할 떄마다 인자로 매번 전달하는 관찰 대상 정보들
	- 해당 정보를 운영체제에게 전달해야 함.
- 운영체제에게 전달하는 이유
	- 소켓은 운영체제에 의해 관리된다.
- select함수의 개선점
	- **운영체제에게 관찰대상에 대한 정보를 한 번만 알려주고, 관찰 대상의 범위, 내용의 변경이 있을 때 변경 사항만 알려주도록 하기.**
	- OS의 동의 하에 이루어진다.
	- 리눅스에서는 epoll, 윈도우에서는 IOCP라고 함
- select 함수를 사용하는 경우
	- 서버의 접속자 수가 많지 않다.
	- 다양한 운영체제에서 운영하려고 한다.
### epoll()
- select의 단점을 극복한 epoll의 특징
	- 상태변화의 확인을 위한 파일 디스크립터 전체를 보는 반복문이 필요 없다.
	- select에 대응하는 epoll_wait 함수 호출시 관찰 대상의 정보를 매번 전달할 필요가 없다.
- epoll 기반 서버 구현에 필요한 함수
	- epoll_create
		- epoll 파일 디스크립터 저장소 생성
	- epoll_ctl
		- 저장소에 파일 디스크립터 등록 및 삭제
		- select()에서 사용했던 FD_SET과 FD_CLR 함수의 대체
	- epoll_wait
		- 파일 디스크립터의 변화를 대기
		- select() 함수에 해당
```c++
struct epoll_event
{
	__uint32_t events;
	epoll_data_t data;
}

	typedef union epoll_data
	{
		void *ptr;
		int fd;
		__uint32_t u32;
		__uint64_t u64;
	} epoll_data_t;
```
- `epoll_event`로 상태변화가 발생한 파일 디스크립터가 별도로 묶인다.
	- epoll_event 기반의 배열을 넉넉한 길이로 선언해서 epoll_wait 호출 시 인자로 전달하면 상태변화가 발생한 파일 디스크립터의 정보가 이 배열에 별도로 묶인다.
### epoll_create
```c++
#inlcude <sys/epoll.h>

int epoll_create(int size);
```
- 반환 값
	- 성공: epoll 파일 디스크립터
	- 실패: -1
- 생성되는 파일 디스크립터의 저장소를 **epoll 인스턴스**라고 한다.
	- 변형되어 부르기도 함.
- size는 epoll 인스턴스의 크기를 결정하는 정보로 사용
	- 운영체제에 요청할 뿐 실제 그 크기로 생성되지 않는다.
		- 2.6.8부터 아예 무시된다.
		- 커널 내에서 epoll 인스턴스의 크기를 유동적으로 관리하기 때문이다.
		- 하지만 다른 버전에서는 유효할 수 있으므로 아예 무시하는 것은 곤란하다.
- epoll 인스턴스, 이 리소스는 소켓처럼 운영체제에 의해 관리된다.
	- 소켓이 생성되는 것과 같이 파일 디스크립터를 반환.
	- 이 함수가 반환하는 파일 디스크립터는 epoll 인스턴스를 구분하는 목적으로 사용.
	- 소멸 시 close() 호출한다.

---
### 생각 (파생된 질문/생각)
- 
### 출 처
- 윤성우의 열혈 TCP IP 소켓 프로그래밍

### 연결 문서: {연결 이유}
- 