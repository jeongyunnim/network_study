---
종류: "문헌"
날짜: "2023-08-30"
인물_저자: "윤성우"
태그: "프로그래밍,네트워크"
출처: "윤성우의 열혈 TCP IP 소켓 프로그래밍"
구분_장소_분류: ""
Alias: "" # 한글/영어
---

### 날짜: 2023-08-30 16:57
### 태그: #프로그래밍/네트워크

>[!메모]
> 

### 학습 내용
---
## Iterative 기반 서버, 클라이언트
### 서버
- accept()를 성공했을 경우 client와 통신을 한 뒤, 종료되면 client 소켓을 닫고 accept로 돌아간다.
### 클라이언트와의 소통
- 프로그램의 기본 동작 방식
	- 서버는 한 번에 하나의 클라이언트와 연결되어 에코 서비스를 제공한다.
	- 서버는 총 다섯 개의 클라이언트에게 순차적으로 서비스를 제공하고 종료한다.
	- 서버는 전송받은 문자열 데이터를 클라이언트에게 재전송 한다.
	- 서버와 클라이언트간의 문자열 에코는 클라이언트가 Q를 입력할 때까지 계속한다.
- Iterable server, client 예제에서의 문제점
```
write(sock, message, strlen(messsage))l
strLen = read(sock, message, BUF_SIZE -1);
message[strLen] = '\0';
std::cout << "Mesasge from server: " << message << std::endl;
```
- read, write 함수가 호출될 때마다 문자열 단위로 입출력이 이루어질 것이다라는 **잘못된 가정**이 존재.
- 서버는 write 함수 호출로 데이터를 전송
	- 데이터 크기가 클 경우 운영체제가 내부적으로 여러 개의 조각으로 나누어서 클라이언트에게 전송한다.
	- 데이터의 모든 조각이 클라이언트에게 전송되지 않았지만 클라이언트가 read를 호출할 수도 있음.
	- 이는 TCP의 전송 특성(**데이터의 경계가 없음**) 때문이다.
- 서버의 read()는 client가 close를 했을 때 0이 반환된다.
---
### 생각 (파생된 질문/생각)
- 
### 출 처
- 윤성우의 열혈 TCP IP 소켓 프로그래밍

### 연결 문서: {연결 이유}
- 