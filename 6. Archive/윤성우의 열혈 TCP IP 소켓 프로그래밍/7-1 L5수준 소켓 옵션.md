---
종류: 문헌
날짜: 2023-09-05
인물_저자: 윤성우
태그: 프로그래밍,네트워크
출처: 윤성우의 열혈 TCP IP 소켓 프로그래밍
구분_장소_분류: ""
aliases: []
---

### 날짜: 2023-09-05 16:40
### 태그: #프로그래밍/네트워크

>[!메모]
> 

### 학습 내용
---
### SO_SNDBUF, SO_RCVBUF
- 각각 출력 버퍼의 크기와 입력 버퍼의 크기와 관련된 옵션.
- 두 옵션을 이용하여 버퍼의 크기를 참조할 수도 있고 변경할 수도 있다.
- 최댓값과 최솟값이 설정 되어있음.
### SO_REUSEADDR
- **Time-wait 상태와 관련**
- 주소할당 에러가 발생했을 경우
	- 항상 클라이언트 측에서 FIN을 보내야한다.
	- 서버 프로세스가 먼저 종료된 경우 에러가 발생한다.
![[Pasted image 20230905161209.png]]
- 호스트A가 서버라면 어떤 문제가 발생하는가?
	- FIN을 보낸 주체는 **Time-wait 상태를 거친 뒤에 소켓이 소멸**된다.
	- 몇 분이 경과한 후에 다시 해당 포트로 소켓을 열 수 있다.
- Time-wait 상태는 왜 필요한가?
	- 호스트 B가 호스트 A의 마지막 ACK를 수신하지 못한 경우, 호스트A가 마지막 ACK를 보내고 **프로세스를 종료**한다면?
		- 호스트 A는 이미 종료되어 버렸으므로 호스트 B는 소켓을 닫지 못한다.
	- 호스트 B가 호스트 A의 마지막 ACK를 수신하지 못한 경우, 호스트A가 마지막 ACK를 보내고 **잠시 대기**한다면?
		- 호스트 B가 마지막 ACK를 받지 못했으므로 직전의 FIN을 재전송한다.
		- 호스트 A가 다시 ACK를 보낼 기회가 생겼다.
![[Pasted image 20230905162947.png]]
- 만약 모종의 이유로 서버를 재빨리 껐다 켜야할 경우
	- Time-wait상태 때문에 몇 분을 기다려야 하는 상황이 발생한다.
	-  네트워크의 상황에 따라 Time-wait이 언제까지 지속될지 모른다.
- Time-wait 상태에 있는 소켓을 다른 port의 소켓으로 재할당할 수 있다.
	- SO_REUSEADDR 옵션을 0(default: false)에서 1로 켜준다.

---
### 생각 (파생된 질문/생각)
>[!배운점]
> Time-wait이 어느 상황에서 일어나고, 어느 상황에서는 일어나지 않는지 확인 해보았다.
> - 1번 사례(정상 종료)
> 	위의 4way-handshaking이 정상적으로 일어났으며, 클라이언트의 time-wait이  생각보다 길게 일어난다는 것을 확인했다. 
> - 2번 사례(클라이언트 시그널 또는 exit 종료)
> 	위와 같다.
> - 3번 사례(서버 종료 후 클라이언트 시그널 종료)
> 	서버에서 time-wait이 진행된다.
> - 4번 사례(서버 종료 후 클라이언트 exit 종료)
> 	: 해당 상황을 만들기 위해서 write()에 입력을 해서 블로킹 상황을 벗어나게 함. read()에서 에러를 감지하여 exit으로 나오게 함.
> 	서버에서 time-wait 상황을 확인할 수 없음. 관련된 모든 소켓이 사라진다. exit은 어떻게 연결된 소켓까지 해치우는 걸까?
### 출 처
- 윤성우의 열혈 TCP IP 소켓 프로그래밍

### 연결 문서: {연결 이유}
- 